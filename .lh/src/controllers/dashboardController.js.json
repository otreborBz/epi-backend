{
    "sourceFile": "src/controllers/dashboardController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1759704480061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1759704480061,
            "name": "Commit-0",
            "content": "const { db } = require('../config/firebase');\n\n/**\n * Gera estatísticas consolidadas para o dashboard.\n */\nconst getStats = async (req, res) => {\n  try {\n    // Usar Promise.all para buscar dados de múltiplas coleções em paralelo\n    const [episSnapshot, colaboradoresSnapshot, entregasSnapshot] = await Promise.all([\n      db.collection('epis').get(),\n      db.collection('colaboradores').get(),\n      db.collection('entregas').get(),\n    ]);\n\n    // --- Cálculo das Estatísticas de EPIs ---\n    let totalEpisDisponiveis = 0;\n    let episVencendo = 0;\n    let episEmFalta = 0;\n    const hoje = new Date();\n    const dataLimiteVencimento = new Date();\n    dataLimiteVencimento.setDate(hoje.getDate() + 30); // Considera EPIs vencendo nos próximos 30 dias\n\n    const epis = [];\n    episSnapshot.forEach(doc => {\n      const epi = { id: doc.id, ...doc.data() };\n      epis.push(epi);\n\n      totalEpisDisponiveis += epi.quantidade;\n      if (epi.quantidade <= 0) {\n        episEmFalta++;\n      }\n      const dataValidade = new Date(epi.validade);\n      if (dataValidade > hoje && dataValidade <= dataLimiteVencimento) {\n        episVencendo++;\n      }\n    });\n\n    // --- Cálculo de Colaboradores e Entregas ---\n    const entregas = [];\n    const colaboradoresComEpi = new Set();\n    entregasSnapshot.forEach(doc => {\n      const entrega = doc.data();\n      entregas.push(entrega);\n      colaboradoresComEpi.add(entrega.colaboradorId);\n    });\n\n    const totalColaboradores = colaboradoresSnapshot.size;\n    const colaboradoresSemEpi = totalColaboradores - colaboradoresComEpi.size;\n\n    // --- Cálculo de EPIs Mais Utilizados ---\n    const usoPorEpi = entregas.reduce((acc, entrega) => {\n      acc[entrega.epiId] = (acc[entrega.epiId] || 0) + entrega.quantidadeEntregue;\n      return acc;\n    }, {});\n\n    const episMaisUtilizados = Object.entries(usoPorEpi)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([epiId, quantidade]) => {\n        const epi = epis.find(e => e.id === epiId);\n        return { nome: epi ? epi.nome : 'EPI não encontrado', quantidade };\n      });\n\n    // --- Cálculo de Uso por Setor ---\n    const colaboradoresMap = new Map();\n    colaboradoresSnapshot.forEach(doc => {\n      colaboradoresMap.set(doc.id, doc.data());\n    });\n\n    const usoPorSetor = entregas.reduce((acc, entrega) => {\n      const colaborador = colaboradoresMap.get(entrega.colaboradorId);\n      if (colaborador && colaborador.setor) {\n        acc[colaborador.setor] = (acc[colaborador.setor] || 0) + entrega.quantidadeEntregue;\n      }\n      return acc;\n    }, {});\n\n    const usoPorSetorFormatado = Object.entries(usoPorSetor).map(([setor, quantidade]) => ({\n      setor,\n      quantidade,\n    }));\n\n    // Monta o objeto de resposta final\n    const stats = {\n      totalEpisDisponiveis,\n      episVencendo,\n      episEmFalta,\n      colaboradoresSemEpi,\n      entregasVencidas: 0, // Lógica a ser implementada\n      episMaisUtilizados,\n      usoPorSetor: usoPorSetorFormatado,\n    };\n\n    return res.status(200).json(stats);\n  } catch (error) {\n    console.error('Erro ao gerar estatísticas do dashboard:', error);\n    return res.status(500).json({ error: 'Erro interno do servidor ao gerar estatísticas.' });\n  }\n};\n\nmodule.exports = {\n  getStats,\n};"
        }
    ]
}